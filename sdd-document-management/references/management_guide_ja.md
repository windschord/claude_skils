# SDDドキュメント管理ガイドライン

このドキュメントは、SDDドキュメント管理スキルの詳細な使用方法とベストプラクティスを説明します。

## 目次

1. [はじめに](#はじめに)
2. [整合性チェックの詳細](#整合性チェックの詳細)
3. [実装同期チェックの詳細](#実装同期チェックの詳細)
4. [アーカイブの詳細](#アーカイブの詳細)
5. [ファイル最適化の詳細](#ファイル最適化の詳細)
6. [トラブルシューティング](#トラブルシューティング)

---

## はじめに

### なぜドキュメント管理が必要か

SDDワークフローで作成されたドキュメントは、開発が進むにつれて以下の問題が発生しやすくなります：

| 問題 | 原因 | 影響 |
|------|------|------|
| 仕様の矛盾 | 変更時の連動更新漏れ | 実装の混乱、バグの原因 |
| 実装との乖離 | 実装後のドキュメント更新忘れ | 新メンバーの混乱、保守性低下 |
| タスクの蓄積 | アーカイブの仕組みがない | 見通しの悪化、管理コスト増 |
| ファイル肥大化 | 継続的な追記 | 可読性低下、編集困難 |

### 管理サイクル

```text
┌─────────────────────────────────────────────────┐
│                                                 │
│    開発  ──→  変更発生  ──→  ドキュメント更新    │
│      ↑                              │           │
│      │                              ↓           │
│      │                        管理スキル実行     │
│      │                              │           │
│      └──────────  整理完了  ←───────┘           │
│                                                 │
└─────────────────────────────────────────────────┘
```

---

## 整合性チェックの詳細

### チェックアルゴリズム

#### 要件カバレッジチェック

```text
1. docs/sdd/requirements/からすべてのREQ-XXX、US-XXXを抽出
2. docs/sdd/design/からすべての設計要素を抽出
3. 各要件に対応する設計要素をマッピング
4. マッピングがない要件を「カバレッジ不足」として報告
```

#### 過剰設計チェック

```text
1. docs/sdd/design/からすべての設計要素を抽出
2. 各設計要素が参照する要件IDを抽出
3. 参照がない設計要素を「過剰設計」として報告
4. ただし、技術的決定（DEC-XXX）は例外とする
```

#### 用語一貫性チェック

```text
1. 各ドキュメントから名詞・専門用語を抽出
2. 同じ概念に異なる用語が使われているか検出
3. 例: 「ユーザー」と「利用者」、「認証」と「ログイン」
```

### マッピングルール

| 要件タイプ | 期待される設計要素 |
|-----------|-------------------|
| ユーザーストーリー (US-XXX) | コンポーネント設計 + API設計 |
| 機能要件 (REQ-XXX) | コンポーネント設計 |
| 非機能要件 (NFR-XXX) | 技術的決定 (DEC-XXX) |

### 検出パターン例

#### パターン1: 新規要件の追加漏れ

```text
状況: 新しいユーザーストーリーUS-010を追加したが、設計を更新していない

検出:
  - US-010: 対応する設計要素なし

推奨アクション:
  - docs/sdd/design/components/に対応するコンポーネント設計を追加
  - docs/sdd/design/api/に対応するAPI設計を追加
```

#### パターン2: 設計の先行追加

```text
状況: 将来の機能のために設計を先に追加したが、要件を定義していない

検出:
  - docs/sdd/design/components/future-feature.md: 対応する要件なし

推奨アクション:
  - docs/sdd/requirements/に対応する要件を追加
  - または、設計を削除（時期尚早な場合）
```

---

## 実装同期チェックの詳細

### API同期チェックの実装

#### 対象ファイルの特定

```text
ドキュメント側:
  - docs/sdd/design/api/*.md
  - OpenAPI/Swagger定義ファイル（存在する場合）

実装側（言語別）:
  - TypeScript/Node.js: src/routes/*.ts, src/controllers/*.ts
  - Python/FastAPI: app/routers/*.py, app/api/*.py
  - Go: internal/handlers/*.go, pkg/api/*.go
```

#### 比較項目

| 項目 | ドキュメントから抽出 | 実装から抽出 |
|------|-------------------|-------------|
| エンドポイント | `## POST /api/users` | `router.post('/api/users', ...)` |
| リクエストボディ | ```json { ... } ``` | 型定義・バリデーションスキーマ |
| レスポンス | ```json { ... } ``` | 戻り値の型定義 |
| ステータスコード | `| 200 | 成功 |` | `res.status(200)` |

### データベース同期チェックの実装

#### 対象ファイルの特定

```text
ドキュメント側:
  - docs/sdd/design/database/*.md
  - docs/sdd/design/database/schema.md

実装側（ツール別）:
  - Prisma: prisma/schema.prisma
  - TypeORM: src/entities/*.ts
  - Drizzle: src/db/schema.ts
  - SQL: migrations/*.sql
```

#### 比較項目

| 項目 | ドキュメントから抽出 | 実装から抽出 |
|------|-------------------|-------------|
| テーブル名 | `## users テーブル` | `model User` / `CREATE TABLE users` |
| カラム定義 | `| id | UUID | PK |` | `id String @id` |
| インデックス | `### インデックス` | `@@index([email])` |
| リレーション | `### リレーション` | `@relation(...)` |

### 乖離の優先度判定

| 優先度 | 条件 | 対応 |
|--------|------|------|
| Critical | APIエンドポイントの不一致 | 即座に対応 |
| High | リクエスト/レスポンス構造の不一致 | 早急に対応 |
| Medium | カラム追加・変更 | 計画的に対応 |
| Low | コメント・説明の不一致 | 余裕があれば対応 |

---

## アーカイブの詳細

### アーカイブポリシー

#### タスクのアーカイブ

| 条件 | アーカイブ |
|------|-----------|
| ステータスがDONE | 対象 |
| ステータスがDONEで完了から30日以上 | 自動推奨 |
| 他のタスクから依存されている | 依存解消後に対象 |
| 進行中フェーズのタスク | 対象外（フェーズ完了まで） |

#### 決定事項のアーカイブ

| 条件 | アーカイブ |
|------|-----------|
| 明示的にアーカイブ指定 | 対象 |
| 代替決定が行われた | 対象（旧決定をアーカイブ） |
| 実装完了から90日以上 | 自動推奨 |

### アーカイブ手順の詳細

```text
1. 対象ファイルの検出
   - docs/sdd/tasks/phase-*/TASK-*.md でステータス=DONEを検索
   - メタデータから完了日を取得

2. 依存関係の確認
   - 他タスクの「依存タスク」フィールドを検索
   - アーカイブ対象への参照がないか確認

3. ユーザー承認
   - 対象リストを提示
   - 依存関係がある場合は警告

4. ファイル移動
   - docs/sdd/archive/tasks/phase-N/ に移動
   - ディレクトリがなければ作成

5. インデックス更新
   - docs/sdd/tasks/index.md から削除
   - docs/sdd/archive/tasks/index.md に追加（なければ作成）

6. 参照の更新（オプション）
   - 他ドキュメントの参照を archive/... に変更
```

### アーカイブインデックスの形式

```markdown
# アーカイブ済みタスク

## 概要

このディレクトリには完了済みのタスクをアーカイブしています。

| フェーズ | タスク数 | 期間 |
|---------|---------|------|
| phase-1 | 15 | 2024-01-01 〜 2024-01-31 |
| phase-2 | 12 | 2024-02-01 〜 2024-02-28 |

## phase-1

| ID | タスク名 | 完了日 | アーカイブ日 |
|----|---------|--------|-------------|
| TASK-001 | ユーザー認証の実装 | 2024-01-15 | 2024-02-01 |
| TASK-002 | API設計の実装 | 2024-01-20 | 2024-02-01 |

## phase-2

[同様の形式]
```

---

## ファイル最適化の詳細

### 分割判断基準

#### 行数による判断

```text
〜500行:   正常（分割不要）
500〜1000行: 注意（内容を確認し、論理的な分割点があれば検討）
1000行〜:  要対応（分割を強く推奨）
```

#### セクション構造による判断

```text
セクション数 < 10:  正常
10 ≤ セクション数 < 20: 注意（関連セクションのグループ化を検討）
セクション数 ≥ 20:  要対応（分割を強く推奨）
```

### 分割戦略

#### 戦略1: 機能別分割

```text
適用条件:
  - 複数の独立した機能が1ファイルに含まれている
  - 各機能が明確に区別できる

例:
  auth.md (1200行)
    → auth/index.md (概要)
    → auth/login.md (ログイン機能)
    → auth/register.md (登録機能)
    → auth/password-reset.md (パスワードリセット)
```

#### 戦略2: レイヤー別分割

```text
適用条件:
  - 異なる抽象度の内容が混在している
  - 概要と詳細が分離できる

例:
  api.md (800行)
    → api/index.md (API概要・共通仕様)
    → api/endpoints.md (エンドポイント一覧)
    → api/authentication.md (認証詳細)
    → api/errors.md (エラーハンドリング詳細)
```

#### 戦略3: 時系列分割

```text
適用条件:
  - 履歴やバージョンの情報が蓄積している
  - 現在の情報と過去の情報を分離したい

例:
  decisions.md (1500行)
    → decisions/index.md (有効な決定の目次)
    → decisions/current/ (現在有効な決定)
    → decisions/superseded/ (置き換えられた決定)
```

### 重複統合戦略

#### パターン1: 共通定義の抽出

```text
状況:
  - docs/sdd/requirements/stories/US-001.md にユーザー属性定義
  - docs/sdd/design/components/user.md にも同じ定義

対応:
  1. docs/sdd/design/common/user-attributes.md を作成
  2. 両ファイルから共通定義を抽出
  3. 各ファイルで参照に変更

結果:
  US-001.md: 「ユーザー属性は[共通定義](../design/common/user-attributes.md)を参照」
  user.md: 「ユーザー属性は[共通定義](common/user-attributes.md)を参照」
```

#### パターン2: 正規化

```text
状況:
  - 同じ内容が複数箇所にコピーされている
  - 一方が更新されると他方と不一致になる

対応:
  1. 正規の定義場所を決定
  2. 他の箇所は参照リンクに変更
  3. 参照元に「詳細は〜を参照」と記載
```

---

## トラブルシューティング

### よくある問題と解決策

#### 問題1: 整合性チェックで大量のエラー

```text
原因: 初期導入時や大規模変更後によく発生

対応:
  1. エラーを優先度でソート
  2. Critical/Highから順に対応
  3. 一度にすべて対応せず、段階的に修正
  4. 各修正後にチェックを再実行
```

#### 問題2: 実装同期チェックが正しく検出できない

```text
原因: 実装の構造がスキルの想定と異なる

対応:
  1. 実装のファイルパターンを確認
  2. 必要に応じてスキルの設定を調整
  3. 手動でマッピングを指定
```

#### 問題3: アーカイブ後に参照エラー

```text
原因: 他ドキュメントからの参照が更新されていない

対応:
  1. エラー箇所を特定
  2. 参照先をarchive/...に更新
  3. または、参照自体を削除（不要な場合）
```

#### 問題4: 分割後にリンク切れ

```text
原因: 分割時にファイル間リンクが更新されていない

対応:
  1. 分割前にリンクを抽出しておく
  2. 分割後にリンクを一括更新
  3. リンクチェッカーで検証
```

### 緊急ロールバック

```text
重大な問題が発生した場合:

1. git status で変更ファイルを確認
2. git diff で変更内容を確認
3. git checkout -- <file> で個別にロールバック
   または
   git reset --hard HEAD で全体をロールバック

注意: コミット前であることを確認してからロールバック
```

---

## 付録

### チェックリスト

#### 整合性チェック前

- [ ] docs/sdd/requirements/ が最新か確認
- [ ] docs/sdd/design/ が最新か確認
- [ ] docs/sdd/tasks/ が最新か確認
- [ ] 未コミットの変更がないか確認

#### アーカイブ前

- [ ] アーカイブ対象の依存関係を確認
- [ ] 現在の状態をコミット済み
- [ ] アーカイブ先ディレクトリの存在を確認

#### 最適化前

- [ ] 分割対象ファイルのバックアップ
- [ ] 参照元ファイルのリストアップ
- [ ] インデックスファイルの現状確認

### 用語集

| 用語 | 説明 |
|-----|------|
| カバレッジ | 要件に対する設計・実装の網羅度 |
| 乖離 | ドキュメントと実装の差異 |
| 正規化 | 重複を排除し単一の情報源にすること |
| アーカイブ | 完了した情報を別の場所に移動して保管すること |
