# タスク実行ガイド

task-executingスキルの詳細な実行手順とエラーハンドリングガイドです。

## タスク実行の詳細ステップ

### ステップ1: タスクの読み取りと分析

```text
1. docs/sdd/tasks/index.mdを読み取る
2. TODO状態のタスクをフィルタリング
3. 各タスクの詳細ファイル（docs/sdd/tasks/[phase]/TASK-XXX.md）を読み込む
4. 各タスクの情報を抽出
   - タスクID
   - タスクタイトル
   - 説明
   - 受入基準
   - 依存関係
   - ステータス
   - 推定工数
5. 依存関係を確認
```

### ステップ2: 実行計画の提示

```text
以下のタスクを実行します：

【実行対象】
- Task 1.1: ユーザー認証APIエンドポイントの実装
  依存関係: なし
  推定工数: 30分

【実行手順】
1. ステータスをIN_PROGRESSに更新
2. サブエージェントで実装
3. 受入基準を確認
4. タスク完了前チェックリスト確認
5. コミット作成
6. ステータスをDONEに更新
7. 逆順レビュー実施

実行を開始してよろしいですか？
```

### ステップ3: 実装実行

サブエージェントに以下の情報を提供：
- タスクファイル（TASK-XXX.md）の完全な内容
- 受入基準
- 技術的文脈
- 参照すべき既存コード
- docs/sdd/design/、docs/sdd/requirements/の関連ファイル

### ステップ4: 受入基準の確認

実装完了後、すべての受入基準を確認：

```text
【受入基準の確認】
- [x] login/logoutエンドポイントが実装されている
- [x] JWTトークンが正しく生成・検証される
- [x] パスワードがbcryptでハッシュ化されている
- [x] エラーハンドリングが適切に実装されている
- [x] ユニットテストが実装され、すべて通過する

すべての受入基準を達成しました。コミットを作成します。
```

### ステップ5: タスク完了前チェックリスト確認

タスク完了をマークする前に、タスク内容を分析して該当するカテゴリのチェックリストを提示し、確認を促します。

#### カテゴリの判定基準

| カテゴリ | 判定条件 |
|---------|---------|
| UI変更 | タスクの説明・受入基準に「コンポーネント」「画面」「レイアウト」「CSS」「スタイル」が含まれる |
| 外部システム連携 | 「Docker」「Git」「API連携」「ファイルシステム」「マウント」が含まれる |
| データ操作 | 「データベース」「クエリ」「リスト」「配列」「入力」「バリデーション」が含まれる |
| コンポーネント再利用 | 「共通化」「リファクタリング」「移動」「再利用」が含まれる |

#### チェックリスト提示の例

```text
【タスク完了前チェック】

Task 2.1: Dockerコンテナ起動スクリプトの実装

該当カテゴリ:
- 外部システム連携（Docker/Git等）を含む

チェックリスト:
[外部システム連携]
- [ ] モックではなく実際のシステムで動作確認した
- [ ] 権限・マウント設定の相互作用を確認した
- [ ] エラー時のログ出力・ハンドリングを確認した

上記の項目をすべて確認しましたか？
```

#### 未確認項目がある場合

```text
【警告】以下の項目が未確認です:

- [ ] 権限・マウント設定の相互作用を確認した

この項目を確認せずに完了とする場合、以下のリスクがあります:
- 本番環境でのみ発生するエラーの見落とし
- 環境依存の問題の見落とし

確認を行いますか？それとも警告を承知の上で完了としますか？
```

### ステップ6: コミット作成とDONE更新

#### 6.1 実装コミットの作成

コミットテンプレートに従ってコミットを作成。
詳細は `commit_templates_ja.md` を参照。

#### 6.2 タスクステータスのDONE更新

タスクファイルとindex.mdのステータスを更新：

```text
1. タスクファイル（docs/sdd/tasks/phase-N/TASK-XXX.md）を編集
   - ステータスを `DONE` に変更
   - 完了サマリーを追加（実装内容の要約）

2. index.md（docs/sdd/tasks/index.md）を編集
   - 該当タスクのステータスを `DONE` に変更
   - 進捗サマリーを更新

3. ステータス更新をコミット
   - コミットメッセージ例: "docs: Mark TASK-XXX as DONE"
```

#### 更新例

```markdown
<!-- TASK-XXX.md -->
## ステータス
DONE

## 完了サマリー
- ユーザー認証APIエンドポイント（/login, /logout）を実装
- JWTトークン生成・検証機能を追加
- bcryptによるパスワードハッシュ化を実装
- ユニットテスト（カバレッジ85%）を追加
```

### ステップ7: 逆順レビュー

実装→タスク→設計→要件の整合性を確認。

## 並列実行（Agentベース）

### 並列実行の条件

- 依存関係フィールドが空、または「なし」
- 前提となるタスクがすべて完了済み
- 異なるファイル・コンポーネントを対象とする

### Agentによる並列実装

**重要**: 並列実行可能なタスクは、Taskツール（subagent_type=general-purpose）を使用して同時に実装を進めます。

```text
【並列実行の手順】
1. docs/sdd/tasks/index.mdを分析し、並列実行可能なタスクを特定
2. 各タスクの詳細ファイルを読み込む
3. 各タスクに対してAgentを起動（1つのメッセージで複数のTaskツールを呼び出す）
4. 各Agentは独立してタスクを実装
5. すべてのAgentが完了後、結果を統合
6. 逆順レビューを実施
```

### Agent起動の例

```text
以下のタスクを並列で実行します：

【Task 1.1】ユーザー認証APIの実装
→ Agent 1を起動

【Task 1.2】ユーザー登録APIの実装
→ Agent 2を起動

【Task 1.3】パスワードリセットAPIの実装
→ Agent 3を起動

各Agentには以下の情報を渡します：
- タスクの詳細（説明、受入基準）
- 関連するdocs/sdd/design/、docs/sdd/requirements/の該当ファイル
- コーディング規約とコミットテンプレート
- テスト要件（カバレッジ80%以上）
```

### Agent実行時の注意事項

1. **コンテキストの共有**: 各Agentに十分な情報を渡す
2. **ファイル競合の回避**: 異なるファイルを対象とするタスクのみ並列化
3. **コミット順序**: 各Agent完了後、メインプロセスで順次コミット
4. **エラーハンドリング**: 1つのAgentが失敗しても他のAgentは継続
5. **結果の検証**: すべてのAgent完了後にテストを実行

## エラーハンドリング

### タスク実行中のエラー

1. エラー内容をユーザーに報告
2. 部分的に完了した作業をコミット（セーフポイント）
3. タスクのステータスをBLOCKEDに変更
4. エラー原因と対処方法を記録
5. ユーザーに次の行動を確認

### エラー報告の例

```text
Task 1.1の実行中にエラーが発生しました：

【エラー内容】
npm install時に依存関係の競合が発生

【実施した内容】
- 基本的なファイル構造を作成（コミット済み）
- パッケージのインストールは未完了

【ステータス】
Task 1.1: BLOCKED

【次の行動】
1. 依存関係の競合を解決してから再実行
2. このタスクをスキップして次のタスクへ進む

どちらにしますか？
```

## 逆順レビュー詳細

### レビューの流れ

```text
実装 → docs/sdd/tasks/ → docs/sdd/design/ → docs/sdd/requirements/
```

### チェック項目

#### 1. 実装 → タスクの整合性

| チェック項目 | 確認内容 |
|-------------|---------|
| 受入基準達成 | すべての受入基準が満たされているか |
| ファイル一致 | タスクで指定されたファイルが作成されているか |
| テスト通過 | 指定されたテストがすべて通過するか |
| コード品質 | ESLint/TypeScriptエラーがないか |

#### 2. タスク → 設計の整合性

| チェック項目 | 確認内容 |
|-------------|---------|
| コンポーネント対応 | 実装がdesign/components/のコンポーネント定義と一致するか |
| API対応 | APIの実装がdesign/api/の仕様と一致するか |
| データモデル対応 | データ構造がdesign/database/のスキーマと一致するか |

#### 3. 設計 → 要件の整合性

| チェック項目 | 確認内容 |
|-------------|---------|
| 要件カバレッジ | 実装が対応する要件（REQ-XXX）を満たしているか |
| 非機能要件 | NFR-XXXの要件が満たされているか |
| 過剰実装チェック | 要件にない機能が実装されていないか |

### 不整合発見時の報告

```text
逆順レビューで以下の不整合を発見しました：

【実装 → タスクの不整合】
1. Task 1.1の受入基準「エラーハンドリングが適切に実装されている」
   が満たされていません。
   → 400エラー時のレスポンス形式がdocs/sdd/design/の仕様と異なります。

【タスク → 設計の不整合】
2. 実装したUserServiceにvalidateEmail()メソッドがありますが、
   design/components/user-service.mdのUserService定義に含まれていません。

【設計 → 要件の不整合】
3. REQ-003「パスワードリセット機能」に対応する実装がありません。

対応方法を選択してください：
1. 実装を修正する
2. ドキュメントを更新する（要確認事項として記録）
3. 次のタスクに進む（後で対応）
```

## Jules CLI統合実行モード

### 概要

Jules CLI（Googleの非同期コーディングエージェント）が利用可能な環境では、タスクの実装をJulesに委任できます。Julesは開発ブランチに対してPR（Pull Request）を作成し、レビュー→マージのフローでタスクを完了させます。

### 実行モードの判定

タスク実行フェーズの開始時に、以下のフローで実行モードを判定します:

```text
┌─────────────────────────────────────────────────────────┐
│               実行モード判定フロー                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Q1. Jules CLIが利用可能か？（jules --version で確認）    │
│      YES → Q2へ                                         │
│      NO  → ローカル実行モード（Agent/Agent Teams）        │
│                                                         │
│  Q2. 開発ブランチが指定されているか？                     │
│      YES → Q3へ                                         │
│      未指定 → ユーザーに開発ブランチを確認 → Q3へ         │
│                                                         │
│  Q3. ユーザーがJules実行を希望するか？                    │
│      全タスクJules → Jules CLIモード                      │
│      一部Jules     → ハイブリッドモード                   │
│      Jules不要     → ローカル実行モード                   │
│                                                         │
│  結果:                                                   │
│  Jules CLIモード     → 全タスクをJulesに依頼、PRベース    │
│  ハイブリッドモード   → 一部Jules（PR）、一部ローカル      │
│  ローカル実行モード   → Agent/Agent Teamsで直接実装        │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Jules CLIモードの実行ステップ

#### ステップ1: 開発ブランチの確認

```text
1. 全体開発で使用する開発ブランチを確認（ユーザーに確認）
2. Julesに依頼する際、PRのターゲットブランチとして開発ブランチを指定
3. JulesはPRごとに自動でフィーチャーブランチを作成する
```

#### ステップ2: タスクの依存関係分析と並列グループ化

```text
1. docs/sdd/tasks/index.mdからTODO状態のタスクを取得
2. 依存関係グラフを構築
3. 並列実行可能なグループを特定:

   例:
   グループA（並列実行可能）:
   - TASK-001: ユーザー認証API（依存なし）
   - TASK-002: データモデル定義（依存なし）
   - TASK-003: 設定ファイル作成（依存なし）

   グループB（グループA完了後）:
   - TASK-004: 認証ミドルウェア（依存: TASK-001）
   - TASK-005: APIバリデーション（依存: TASK-001, TASK-002）

4. 各グループ内のタスクは複数のJulesインスタンスで同時実行
```

#### ステップ3: Jules依頼文の作成

各タスクについて、以下の情報を含む依頼文を作成します:

```text
タスク: [タスクタイトル]（[TASK-XXX]）

概要:
[タスクの詳細な説明]

受入基準:
- [基準1]
- [基準2]

技術的文脈:
- [フレームワーク、ライブラリ]
- [参照すべきファイルやコード]
- [制約事項]

開発ブランチ: [ブランチ名]
PR作成先: [開発ブランチ名]

コミット規約:
- feat/fix/docs等のprefixを使用
- タスクIDを含める（例: feat(auth): implement login endpoint [TASK-001]）
```

#### ステップ4: 複数Julesへの非同期依頼

並列実行可能なタスクは、複数のjulesコマンドを連続投入し、非同期タスクとして並行進行させます。各julesコマンドは即座に制御を返し、Jules側で非同期に作業が進行します:

```bash
# グループA: 3タスクを連続投入（各コマンドは非同期タスクを作成して即座に返る）
jules "$(cat <<'EOF'
タスク: ユーザー認証APIの実装（TASK-001）
...
PR作成先: develop
EOF
)"

jules "$(cat <<'EOF'
タスク: データモデルの定義（TASK-002）
...
PR作成先: develop
EOF
)"

jules "$(cat <<'EOF'
タスク: 設定ファイルの作成（TASK-003）
...
PR作成先: develop
EOF
)"
```

#### ステップ5: 進捗追跡とPR管理

```text
1. jules listで全タスクの進捗を一覧確認
2. 各タスクの状態に応じてdocs/sdd/tasks/を更新:

   Jules状態        → SDD状態       → TodoWrite
   ─────────────────────────────────────────────
   作業中           → IN_PROGRESS   → in_progress
   PR作成済み       → REVIEW        → in_progress（[REVIEW]付記）
   PRマージ済み     → DONE          → completed

3. PR作成時にPR番号をタスクファイルに記録:
   - Jules Task ID: task-abc123
   - PR: #42
   - PRブランチ: jules/task-001-auth-api

4. PRレビューはユーザーまたはリーダーが実施
5. PRマージ後にDONEに遷移
```

#### ステップ6: グループ間の順次実行

```text
グループA完了（全PRマージ済み）
      ↓
開発ブランチを最新に更新（git pull）
      ↓
グループBのタスクをJulesに依頼
      ↓
以降繰り返し
```

### タスクファイルへの段階的記録

Julesで実行したタスクには、進行に応じて段階的に情報を追記します:

**段階1: Jules依頼時（Jules Task IDを即時記録）**

```markdown
## 実行情報
**実行方式**: Jules CLI
**Jules Task ID**: task-abc123
**PR作成先**: develop
**開始日時**: 2025-01-15 10:30
```

**段階2: PR作成時（PR番号・ブランチを追記）**

```markdown
**PR番号**: #42
**PRブランチ**: jules/task-001-auth-api
**PR作成日時**: 2025-01-15 12:15
```

**段階3: PRマージ時（マージ日時を追記、完了日時 = マージ日時）**

```markdown
**マージ日時**: 2025-01-15 14:00
```

### ハイブリッドモード

一部のタスクをJulesに、一部をローカル（Agent/Agent Teams）で実行する場合:

```text
割り当て判定基準:
┌─────────────────────────────────────────────────────────┐
│ Julesに向いているタスク:                                 │
│ - 明確な受入基準がある独立したタスク                      │
│ - 標準的な実装パターン（CRUD、API、モデル定義等）         │
│ - 時間がかかるが定型的な作業                              │
│                                                         │
│ ローカル実行に向いているタスク:                           │
│ - 既存コードの複雑なリファクタリング                      │
│ - 対話的な判断が必要なタスク                              │
│ - ローカル環境固有の作業（Docker設定、環境構築等）        │
│ - 複数ファイルの密結合な変更                              │
└─────────────────────────────────────────────────────────┘
```

### Jules + Agent Teams連携パターン

エージェントチームとJulesを組み合わせて最大効率を実現するパターン:

```text
チームリーダー（オーケストレーター）
├── Jules依頼管理:
│   ├── Jules-1: TASK-001（PR #41）
│   ├── Jules-2: TASK-002（PR #42）
│   └── Jules-3: TASK-003（PR #43）
├── ローカルAgent:
│   └── Agent-1: TASK-004（ローカル環境依存タスク）
└── 進捗管理:
    ├── jules listで定期確認
    ├── PRレビュー・マージ管理
    ├── docs/sdd/tasks/の更新
    └── TodoWriteの同期

手順:
1. リーダーがタスクを分析し、Jules向け/ローカル向けに分類
2. Jules向けタスクを複数のjulesコマンドで同時依頼
3. ローカル向けタスクはAgent Teams/Task toolで並列実行
4. リーダーはjules listで定期的にJulesの進捗を確認
5. PR作成されたらレビューし、問題なければマージ
6. 全タスク完了後にdocs/sdd/tasks/とTodoWriteを一括更新
7. 逆順レビューを実施
```

### エラーハンドリング（Jules固有）

```text
1. Jules依頼が失敗した場合:
   - jules status <task-id>でエラー内容を確認
   - 依頼文を修正して再依頼（jules retry <task-id>）
   - 繰り返し失敗する場合はローカル実行にフォールバック

2. PRにコンフリクトが発生した場合:
   - 開発ブランチの最新を取得
   - コンフリクトを解消
   - 必要に応じてJulesに再依頼

3. PRレビューで問題が見つかった場合:
   - Julesに修正を依頼（新規タスクとして）
   - または手動で修正してPRを更新
   - 修正内容をタスクファイルに記録

4. Julesが長時間応答しない場合:
   - jules status <task-id>で状態確認
   - 必要に応じてjules cancel <task-id>でキャンセル
   - ローカル実行にフォールバック
```

## 制約事項

### 自動実行を行わない場合

1. **タスクの曖昧性**: 受入基準が明確でない、実装方法が複数考えられる
2. **リスクの高い操作**: 本番環境への変更、データベースの削除操作
3. **ユーザーの判断が必要**: 技術選択、アーキテクチャの決定

これらの場合はユーザーに確認を求めます。
